## How it works

### ArangoDB concepts

stix2arango uses the following [ArangoDB data functions to do this](https://www.arangodb.com/docs/stable/data-structure.html);

1. Databases
2. Vertex Collections
3. Edge Collections

When executing the upload of a STIX object or STIX bundle they must select a;

* Database name: will create a database named as follows `<NAME>_database`. If database does not exist, one is created. Note, when entering name in the future, only the `<NAME>` part should ever be used.
* Collection name: will create a two collections, a vertex and edge, as follows `<NAME>_vertex_collection` and `<NAME>_edge_collection`. If collections do not exist, they are created. Note, when entering name in the future, only the `<NAME>` part should ever be used.

### STIX support and validation

A user must enter a valid STIX 2.1 bundle.

STIX objects in the bundle are validated against the STIX 2.1 spec. The assumption is that all objects have been generated by the STIX2 Python library and are valid.

The way STIX objects are stored depends on their type. Here is a list of all the possible STIX objects that can be ingested;

* [SDOs](https://docs.oasis-open.org/cti/stix/v2.1/os/stix-v2.1-os.html#_nrhq5e9nylke): STIX Domain Objects
	* A list of standard SDO `"type"`s is defined in the STIX specification. Can also be non-standard SDO, if an Extension Definition object is nested inside the object with `"extension_type": "new-sdo"`.
* [SCOs](https://docs.oasis-open.org/cti/stix/v2.1/os/stix-v2.1-os.html#_mlbmudhl16lr): STIX Cyber Observable Objects
	* A list of standard SCO `"type"`s is defined in the STIX specification. Can also be non-standard SDO, if an Extension Definition object is nested inside the object with `"extension_type": "new-sco"`.
* [SROs](https://docs.oasis-open.org/cti/stix/v2.1/os/stix-v2.1-os.html#_cqhkqvhnlgfh): STIX Relationship Objects
	* must be type `relationship` or `sighting`
* [SMOs](https://docs.oasis-open.org/cti/stix/v2.1/os/stix-v2.1-os.html#_mq8oo9k9rb2): STIX Meta Objects
	* must be type `language-content` or `marking-definition`
* [SBOs](https://docs.oasis-open.org/cti/stix/v2.1/os/stix-v2.1-os.html#_gms872kuzdmg) STIX Bundle Objects (wrapper of other STIX objects)
	* must be type `bundle`

Note for all standard object types, additional non-standard properties (in addition to those found in the STIX specification) can be added if there is an Extension Definition object is nested inside the object with `"extension_type": "property-extension"`.

### Bundles

Bundles can be detected where the `type` property is `bundle`. e.g.

```json
{
    "type": "bundle",
    "id": "bundle--<ID>",
    "objects": [
```

For bundles of objects, each object extracted and then treated as a separate STIX object.

### Order of bundle import / relationship generation

The next section of this document describes how STIX objects are inserted (and in some cases created). The order of insert, especially in the case of bundles is as follows;

1. STIX SMOs
2. STIX SDOs
3. STIX SCOs
4. STIX SROs
5. Creation of STIX SROs for nested references

### Default STIX objects

The following objects are automatically inserted to each vertex collection on creation.

They should have the following custom properties

* `_stix2arango_note`: `automatically imported on collection creation`
* `_record_created`: time of collection creation
* `_record_modified`: time of collection creation
* `_record_md5_hash`: hash of object
* `_is_latest`: `true`

The are added like so;

```sql
LET default_objects = [
    {
        "_key": "<THE OBJECTS STIX ID>",
        "_stix2arango_note": "automatically imported object at script runtime",
        "_record_created": "<DATETIME OBJECT WAS INSERTED IN DB>",
        "_record_modified": "<DATETIME OBJECT WAS INSERTED IN DB>",
        "_record_md5_hash": "<HASH OF OBJECT>",
        "_is_latest": true,
        "<DEFAULT STIX OBJECT>"
    }
]
FOR default_object IN default_objects
INSERT default_object INTO <SOURCE>_vertex_collection
```

#### TLPs Marking definitions

These can be found in `templates/marking-definition.json`

#### Marking definitions

* https://raw.githubusercontent.com/muchdogesec/stix4doge/main/objects/marking-definition/stix2arango.json

#### Identities (`identity`) SDOs

* https://raw.githubusercontent.com/muchdogesec/stix4doge/main/objects/identity/stix2arango.json (identity used to create embedded relationship objects)
* https://raw.githubusercontent.com/muchdogesec/stix4doge/main/objects/identity/dogesec.json (seeded in all bundles)

### A note on STIX object life-cycle

STIX objects all contain an `id`. An `id` denotes a single objects. Updates to an object can occur over time (e.g. property values changed), however the ID will remain the same.

The way arango2stix handles this is dependent on the object type due to their differences. This logic is described later in this document.

### INSERT New Objects to Vertex Collections

All STIX 2.1 SDOs, SCOs, SMOs and Sightings that have not been added to the collection (that is, the `id` of the object is not already in the collection) are added to the ArangoDB vertex collections selected by the user as follows;

```sql
LET objects = [
    {
        "_key": "<THE OBJECTS STIX ID>",
        "_bundle_id": "<THE BUNDLE ID>",
        "_file_name": "<FILENAME OF IMPORT>",
        "_stix2arango_note": "<IF ENTERED BY USER ON IMPORT>",
        "_record_created": "<DATETIME OBJECT WAS INSERTED IN DB>",
        "_record_modified": "<DATETIME OBJECT WAS LAST MODIFIED IN DB>",
        "_record_md5_hash": "<HASH OF OBJECT>",
        "_is_latest": true,
        "<STIX SDO, SCO, SMO, Sighting PROPERTIES>"
    }
]
FOR object IN objects
INSERT object INTO <NAME>_vertex_collection
```

Note the use of [default and custom ArangoDB attributes](https://docs.arangodb.com/3.11/concepts/data-structure/documents/) (e.g. `_bundle_id`).

Where:

* `_key`: for new objects, the ID of the STIX object, e.g. `indicator--8e2e2d2b-17d4-4cbf-938f-98ee46b3cd3f`
* `_file_name`: is the filename of the file imported by the user
* `_stix2arango_note`: is the value entered by user (if any) on import using `--stix2arango_note`
* `_bundle_id`: if the object was extracted from a bundle, this is the bundle ID it was extracted from (e.g. `bundle--31b940d4-6f7f-459a-80ea-9c1f17b5891b`). If it was not imported from a bundle, this property is not shown.
* `_record_created`: the datetime the object was inserted into the database (e.g. `2020-01-01T01:00:00.000Z`)
* `_record_modified`: the datetime the object was last updated (e.g. `2020-01-01T01:00:00.000Z`). Note, for new objects this always matches the `_record_created` time
* `_record_md5_hash` is an MD5 hash of the STIX objects and the `_stix2arango_note` field. This is used to detect updates to objects.
* `is_latest`: boolean, for newly inserted objects will always be `true`. See update logic to understand why.

For example inserting an object from a bundle into a collection named `demo`;

```sql
LET objects = [
    {
        "_key": "vulnerability--00008327-8c28-5aa7-81ed-43a1f9d34e07",
        "_bundle_id": "bundle--c4d4dc95-47ea-41cb-a24d-c9d872eb4368",
        "_file_name": "bundle--c4d4dc95-47ea-41cb-a24d-c9d872eb4368.json",
        "_stix2arango_note": "vulnerabilty_bundle_20220120",
        "_record_created": "2020-01-01T00:00:00.000Z",
        "_record_modified": "2020-01-01T00:00:00.000Z",
        "_record_md5_hash": "50843d84b5678c36789b9ebd150f24ad",
        "_is_latest": true,
        "type": "vulnerability",
	    "spec_version": "2.1",
	    "id": "vulnerability--00008327-8c28-5aa7-81ed-43a1f9d34e07",
	    "created_by_ref": "identity--7a1fea52-aa94-4f85-bc5e-c55dd4e1896b",
	    "created": "2019-12-31T09:15:15.347Z",
	    "modified": "2021-01-14T21:20:28.997Z",
	    "name": "CVE-2020-35909"
    }
]
FOR object IN objects
INSERT object INTO demo_vertex_collection
```

### UPDATE Existing Objects in Vertex Collections

All vertex objects contain an MD5 has of all the STIX properties and the `_record_md5_hash`.

If the `_record_md5_hash` changes for an object, then an update to the record is required (note, the update may be inserting an older object as well as inserting a newer object).

Depending on the STIX object type, the following behaviour happens to perform the updates;

#### 1. SDOs

SDOs are required that they contain `modified` (as datetime) and `_stix2arango_note` (can be blank).

First stix2arango checks if identical object with same `id` to the one being imported already exists in the DB.

If an existing version of the object does exist, the `_record_md5_hash` is compared between each record (note, many records for an `id` may exist).

If `_record_md5_hash` already exists for `id`, then no update is due and record is skipped.

If a new `_record_md5_hash` exists for `id` then an update happens.

##### 1.1 If update is latest version of the object

If the `modified` time of the new object is greater than or equal to the `_is_latest` copy of that object then a copy of the current object in DB is first made to create a historic object from the old latest version as follows;

```sql
LET objects = [
    {
        "_key": "<THE OBJECTS STIX ID>+<STIX MODIFIED VALUE>",
        "_bundle_id": "<IF ORIGINALLY UPLOADED IN A BUNDLE, THE BUNDLE ID, ELSE BLANK>",
        "_file_name": "<FILENAME OF ORIGINAL IMPORT>",
        "_stix2arango_note": "<NOTE OF ORIGINAL IMPORT>",
        "_record_created": "<DATE OF TIME THIS RECORD CREATED IN DB>",
        "_record_modified": "<DATETIME OF COPY TIME IN DB>",
        "_record_md5_hash": "<HASH OF OBJECT>",
        "_is_latest": false,
        "<COPIED STIX OBJECT>"
    }
]
FOR object IN objects
INSERT object INTO <NAME>_vertex_collection
```

Historic object versions created like this (where `"_is_latest": false`) are never modified once created like this. Many historic objects can exist for a single `id`.

The original record of the object is then updated with the newly imported object and its updated properties;

```sql
LET objects = [
    {
        "_key": "<THE OBJECTS STIX ID>",
        "_bundle_id": "<THE BUNDLE ID>",
        "_file_name": "<FILENAME OF IMPORT>",
        "_stix2arango_note": "<IF ENTERED BY USER ON IMPORT>",
        "_record_created": "<DATE ORIGINAL RECORD FOR ID CREATED IN DB>",
        "_record_modified": "<DATETIME OF UPDATE IN DB>",
        "_record_md5_hash": "<HASH OF OBJECT>",
        "_is_latest": true,
        "<UPDATED STIX OBJECT>"
    }
]
FOR object IN objects
UPDATE object INTO <NAME>_vertex_collection
```

This means version of the object where the `_key` matches the `id` is always the latest (but this can also be identified using the `_is_latest` property for more efficient retrieval).

Note, the `_record_created` will remain unchanged to the original object, however, the `_record_modified` is updated to match the time record updated with new information.

##### 1.2 If update is older version of the object

If the `modified` time of the new object being imported is less than `_is_latest` object then a new object is created to represent the older version of this object this update represents. The latest version of the object remains unchanged.

Here is how the old version of the object being imported is represented;

```sql
LET objects = [
    {
        "_key": "<THE OBJECTS STIX ID>+<STIX MODIFIED VALUE>",
        "_bundle_id": "<THE BUNDLE ID>",
        "_file_name": "<FILENAME OF ORIGINAL IMPORT>",
        "_stix2arango_note": "<IF ENTERED BY USER ON IMPORT>",
        "_record_created": "<DATETIME OBJECT WAS INSERTED IN DB>",
        "_record_modified": "<DATETIME OBJECT WAS LAST MODIFIED IN DB>",
        "_record_md5_hash": "<HASH OF OBJECT>",
        "_is_latest": false,
        "<COPIED STIX OBJECT>"
    }
]
FOR object IN objects
INSERT object INTO <NAME>_vertex_collection
```

##### 1.3 If modified time is the same, but hash different

Note, there are occasions where the STIX objects are identical between updated (inc. having same `modified` times).

However, because md5 hash property considers `_stix2arango_note` field then any change in this can force an update. In these circumstances where `modified` times between updates are identical, the object imported most recently becomes the `_is_latest==true`.

#### 2. SCOs

SCOs never have `created` or `modified` properties. Thus, time cannot be used as a judge of update.

As such, for SCOs it is assumed the most recently imported object (with unique `_record_md5_hash` for the `id`) is the latest.

In a similar way to SDOs, the old object record is first copied to create an old version of it as follows;

```sql
LET objects = [
    {
        "_key": "<THE OBJECTS STIX ID>+<_record_created>",
        "_bundle_id": "<THE BUNDLE ID>",
        "_file_name": "<FILENAME OF ORIGINAL IMPORT>",
        "_stix2arango_note": "<NOTE OF ORIGINAL IMPORT>",
        "_record_created": "<DATE OF TIME THIS RECORD CREATED IN DB>",
        "_record_modified": "<DATETIME OF COPY TIME IN DB>",
        "_record_md5_hash": "<HASH OF OBJECT>",
        "_is_latest": false,
        "<COPIED STIX OBJECT>"
    }
]
FOR object IN objects
INSERT object INTO <NAME>_vertex_collection
```

And again, like with SDOs the original version of the object is then updated with the new properties for the object being posted.

```sql
LET objects = [
    {
        "_key": "<THE OBJECTS STIX ID>",
        "_bundle_id": "<THE BUNDLE ID>",
        "_file_name": "<FILENAME OF IMPORT>",
        "_stix2arango_note": "<IF ENTERED BY USER ON IMPORT>",
        "_record_created": "<DATE OF RECORD CREATED, DOES NOT CHANGE>",
        "_record_modified": "<DATETIME OF UPDATE IN DB>",
        "_record_md5_hash": "<HASH OF OBJECT>",
        "_is_latest": true,
        "<UPDATED STIX OBJECT>"
    }
]
FOR object IN objects
UPDATE object INTO <NAME>_vertex_collection
```

#### 3. SMOs

`language-content` objects require `created` and `modified` properties.

Therefore, `language-content` objects are treated like SDOs in case of updates.

`marking-definition` objects only require a `created` property.

`marking-definition` therefore don't have enough time information to represent updates, thus are treated like SCOs in case of updates.

#### 4. Sighting (SROs)

Because sightings contain `created` and `modified` properties updates are treated in the same way as SDOs.

#### 5. A note on searching updates

Unless you are looking for an old version, it is recommended to include the filter `_is_latest==true` in ArangoDB.

### Adding New Objects to Edge collections

#### A note on `_to` and `_from` validation

ArangoDB uses the `_from` and `_to` in edge collections to denote the source and target object in a relationship.

This means the source and target objects must exist in ArangoDB else the creation of them will result in an error.

As noted earlier, some STIX objects are automatically inserted into a collection on its creation. However, this only covers certain STIX objects (e.g TLP).

Generally if importing a STIX 2.1 bundle, all objects referenced in it are also contained inside of it.

If this is not the case, or you choose to upload objects individually you need to ensure any relationships arango2stix will create (as described below) already exist, else you will run into an error.

#### New Relationship SROs

SROs of type `relationship` represent relationships (edges) between two STIX objects they are added to ArangoDB edge collections.

New Relationship SROs (where no other object imported already has same `id`) can be inserted to ArangoDB as follows;

```sql
LET relationships = [
    {
        "_key": "<THE OBJECTS STIX ID>",
        "_from": "<COLLECTION NAME>/<OBJECTS SOURCE_REF>",
        "_to": "<COLLECTION NAME>/<OBJECTS TARGET_REF>",
        "_bundle_id": "<THE BUNDLE ID>",
        "_file_name": "<FILENAME OF IMPORT>",
        "_stix2arango_note": "<IF ENTERED BY USER ON IMPORT>",
        "_record_created": "<DATETIME OBJECT WAS INSERTED IN DB>",
        "_record_modified": "<DATETIME OBJECT WAS LAST MODIFIED IN DB>",
        "_record_md5_hash": "<HASH OF OBJECT>",
        "_is_latest": true,
        "_is_ref": false,
        "<STIX Relationship OBJECT PROPERTIES>"
    }
]
FOR relationship IN relationships
INSERT relationship INTO <NAME>_edge_collection
```

Where;

* `_is_ref`: boolean, denotes if object was created by a ref or refs property insides a STIX object (see refs section). Will always be `false` if created from relationship type objects.

For example;

```sql
LET relationships = [
    {
        "_key": "relationship--00ccf332-d848-586e-af0a-4004097dba20",
        "_from": "demo_vertex_collection/indicator--00ccf332-d848-586e-af0a-4004097dba20",
        "_to": "demo_vertex_collection/vulnerability--00ccf332-d848-586e-af0a-4004097dba20",
        "_bundle_id": "bundle--c4d4dc95-47ea-41cb-a24d-c9d872eb4368",
        "_file_name": "bundle--c4d4dc95-47ea-41cb-a24d-c9d872eb4368.json",
        "_stix2arango_note": "vulnerabilty_bundle_20220120",
        "_record_created": "2020-01-01T00:00:00.000Z",
        "_record_modified": "2020-01-01T00:00:00.000Z",
        "_record_md5_hash": "1cfa2a4e9ef359a410d9708c4fc15957",
        "_is_latest": true,
        "_is_ref": false,
		"type": "relationship",
		"spec_version": "2.1",
		"id": "relationship--00ccf332-d848-586e-af0a-4004097dba20",
		"created_by_ref": "identity--7a1fea52-aa94-4f85-bc5e-c55dd4e1896b",
		"created": "2008-12-12T18:30:02.843Z",
		"modified": "2021-04-09T13:52:56.360Z",
		"relationship_type": "identifies",
		"source_ref": "indicator--00ccf332-d848-586e-af0a-4004097dba20",
		"target_ref": "vulnerability--00ccf332-d848-586e-af0a-4004097dba20"
        }
    }
]
FOR relationship IN relationships
INSERT relationship INTO demo_edge_collection
```

#### Updating SROs

Because `relationship` objects must contain `created` and `modified` properties, updates to `relationship` SROs are done in the same way as SDO updates.

##### A note on searching updates

Unless you are looking for an old relationships, it is recommended to include the filter `_is_latest==true` in ArangoDB.

#### Embedded relationships

All STIX 2.1 Objects (SDOs, SCOs, SMOs, SROs) can also have embedded relationships found in properties ending in `_ref` (single reference to object) or `_refs` (list of references to one or more object).

e.g. 

```json
	"created_by_ref": "identity--c78cb6e5-0c4b-4611-8297-d1b8b55e40b5"
```

```json
	"object_refs": [
		"file--30038539-3eb6-44bc-a59e-d0d3fe84695a"
	]
```

The following attributes exist for `ref` / `_refs` in the STIX specification:

`_refs`;

* `analysis_sco_refs`
* `bcc_refs`
* `belongs_to_refs`
* `cc_refs`
* `child_refs`
* `contains_refs`
* `encapsulates_refs`
* `installed_software_refs`
* `object_marking_refs`
* `object_refs`
* `observed_data_refs`
* `opened_connection_refs`
* `resolves_to_refs`
* `sample_refs`
* `service_dll_refs`
* `to_refs`
* `where_sighted_refs`

`_ref`;

* `body_raw_ref`
* `created_by_ref`
* `creator_user_ref`
* `dst_payload_ref`
* `dst_ref`
* `encapsulated_by_ref`
* `from_ref`
* `host_vm_ref`
* `image_ref`
* `marking_ref`
* `object_ref`
* `operating_system_ref`
* `parent_directory_ref`
* `parent_ref`
* `raw_email_ref`
* `sample_ref`
* `sender_ref`
* `sighting_of_ref`
* `src_payload_ref`
* `src_ref`

Such references will not natively be created by Arango as edges, meaning you can not traverse the graph using these properties.

To solve this problem stix2arango will create STIX Relationship objects for supported attribute ending with `ref` / `_refs`.

The following default `_ref` attributes that are not be considered are the following (as they are found in relationship objects, and thus an SRO already exists);

* `source_ref`
* `target_ref`

When a supported `_ref` or `_refs` property is detected inside a STIX object a new relationship object is created at the end of the import job (after all other actions). This is done using the STIX2 Python library, and such relationships are generated in the following structure;

```json
{
	"type": "relationship",
	"spec_version": "2.1",
    "id": "relationship--<UUID v5>",
	"created_by_ref": "<IMPORTED STIX2ARANGO IDENTITY ID>",
	"relationship_type": "<EMBEDDED RELATIONSHIP TYPE>",
	"created": "<OBJECT CREATED TIME>",
	"modified": "<OBJECT MODIFIED TIME>",
    "source_ref": "<OBJECT WITH REF PROPERTY>",
    "target_ref": "<REF TARGET PROPERTY>",
    "object_marking_refs": [
        "<object_marking_refs SHOULD MATCH SOURCE_REF OBJECT>"
    ]
}
```

Note, to ensure the SRO `id` persists when the same relationship is described, SROs `id`s are created using UUIDv5 strings as follows:

* namespace: `72e906ce-ca1b-5d73-adcd-9ea9eb66a1b4`
* value: `<RELATIONSHIP_TYPE>+<SOURCE_REF>+<TARGET_REF>`

This object can then be inserted into the database as per the normal Relationship SRO import process.

```sql
LET ref_relationships = [
    {
        "_key": "<THE OBJECTS STIX ID>+<DATETIME OF INSERT>",
        "_from": "<COLLECTION NAME>/<OBJECTS SOURCE_REF>",
        "_to": "<COLLECTION NAME>/<OBJECTS TARGET_REF>",
        "_stix2arango_note": "<SAME AS SOURCE_REF VALUE>",
        "_record_created": "<DATETIME OBJECT WAS INSERTED IN DB>",
        "_record_modified": "<DATETIME OBJECT WAS LAST MODIFIED IN DB>",
        "_record_md5_hash": "<HASH OF OBJECT>",
        "_is_latest": true,
        "_is_ref": true,
        "<CREATED STIX OBJECTS>"
    }
]
FOR relationship IN ref_relationships
INSERT relationship INTO <NAME>_edge_collection
```

The `_is_ref` property is always `true` for embedded relationships allowing them to be easily filtered in Arango search.

IMPORTANT, all embedded relationships assume the `target_ref` object is in the same collection (hence why bundle should contain any embedded relationship STIX objects).

### A note on performance

stix2arango has considered performance (e.g. to allow the backfill of 200,000 CPEs).

However, stix2arango has not been optimised for performance of large datasets. For our use-cases, we will import a large dataset once, and then iterate through new imports with smaller volumes. For example, backfilling the CPE records from the year 2000 (over 1 million), and then checking daily for new CPEs/updated CPEs and importing them (no more than 1000 per week, usually).